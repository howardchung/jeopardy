{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _values from \"lodash-es/values\";\nimport _get from \"lodash-es/get\";\nimport _has from \"lodash-es/has\";\nimport _forEach from \"lodash-es/forEach\";\nimport _mapValues from \"lodash-es/mapValues\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { getElementType, getUnhandledProps, SUI } from '../../lib';\nimport { getChildMapping, mergeChildMappings } from './utils/childMapping';\nimport wrapChild from './utils/wrapChild';\n\n/**\n * A Transition.Group animates children as they mount and unmount.\n */\nvar TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TransitionGroup, _React$Component);\n  function TransitionGroup() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      // Keeping a callback under the state is a hack to make it accessible under getDerivedStateFromProps()\n      handleOnHide: function handleOnHide(nothing, childProps) {\n        var reactKey = childProps.reactKey;\n        _this.setState(function (state) {\n          var children = _extends({}, state.children);\n          delete children[reactKey];\n          return {\n            children: children\n          };\n        });\n      }\n    };\n    return _this;\n  }\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var animation = props.animation,\n      duration = props.duration,\n      directional = props.directional;\n    var prevMapping = state.children; // A short circuit for an initial render as there will be no `prevMapping`\n\n    if (typeof prevMapping === 'undefined') {\n      return {\n        children: _mapValues(getChildMapping(props.children), function (child) {\n          return wrapChild(child, state.handleOnHide, {\n            animation: animation,\n            duration: duration,\n            directional: directional\n          });\n        })\n      };\n    }\n    var nextMapping = getChildMapping(props.children);\n    var children = mergeChildMappings(prevMapping, nextMapping);\n    _forEach(children, function (child, key) {\n      var hasPrev = _has(prevMapping, key);\n      var hasNext = _has(nextMapping, key);\n      var prevChild = prevMapping[key];\n      var isLeaving = !_get(prevChild, 'props.visible'); // Heads up!\n      // An item is new (entering), it will be picked from `nextChildren`, so it should be wrapped\n\n      if (hasNext && (!hasPrev || isLeaving)) {\n        children[key] = wrapChild(child, state.handleOnHide, {\n          animation: animation,\n          duration: duration,\n          directional: directional,\n          transitionOnMount: true\n        });\n        return;\n      } // Heads up!\n      // An item is old (exiting), it will be picked from `prevChildren`, so it has been already\n      // wrapped, so should be only updated\n\n      if (!hasNext && hasPrev && !isLeaving) {\n        children[key] = /*#__PURE__*/React.cloneElement(prevChild, {\n          visible: false\n        });\n        return;\n      } // Heads up!\n      // An item item hasn't changed transition states, but it will be picked from `nextChildren`,\n      // so we should wrap it again\n\n      var _prevChild$props = prevChild.props,\n        visible = _prevChild$props.visible,\n        transitionOnMount = _prevChild$props.transitionOnMount;\n      children[key] = wrapChild(child, state.handleOnHide, {\n        animation: animation,\n        duration: duration,\n        directional: directional,\n        transitionOnMount: transitionOnMount,\n        visible: visible\n      });\n    });\n    return {\n      children: children\n    };\n  };\n  var _proto = TransitionGroup.prototype;\n  _proto.render = function render() {\n    var children = this.state.children;\n    var ElementType = getElementType(TransitionGroup, this.props);\n    var rest = getUnhandledProps(TransitionGroup, this.props);\n    return /*#__PURE__*/React.createElement(ElementType, rest, _values(children));\n  };\n  return TransitionGroup;\n}(React.Component);\nTransitionGroup.handledProps = [\"animation\", \"as\", \"children\", \"directional\", \"duration\"];\nexport { TransitionGroup as default };\nTransitionGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** An element type to render as (string or function). */\n  as: PropTypes.elementType,\n  /** Named animation event to used. Must be defined in CSS. */\n  animation: PropTypes.oneOfType([PropTypes.oneOf(SUI.TRANSITIONS), PropTypes.string]),\n  /** Primary content. */\n  children: PropTypes.node,\n  /** Whether it is directional animation event or not. Use it only for custom transitions. */\n  directional: PropTypes.bool,\n  /** Duration of the CSS transition animation in milliseconds. */\n  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    hide: PropTypes.number.isRequired,\n    show: PropTypes.number.isRequired\n  }), PropTypes.string])\n} : {};\nTransitionGroup.defaultProps = {\n  as: React.Fragment,\n  animation: 'fade',\n  duration: 500\n};","map":{"version":3,"names":["_extends","_inheritsLoose","_values","_get","_has","_forEach","_mapValues","PropTypes","React","getElementType","getUnhandledProps","SUI","getChildMapping","mergeChildMappings","wrapChild","TransitionGroup","_React$Component","_this","_len","arguments","length","args","Array","_key","call","apply","concat","state","handleOnHide","nothing","childProps","reactKey","setState","children","getDerivedStateFromProps","props","animation","duration","directional","prevMapping","child","nextMapping","key","hasPrev","hasNext","prevChild","isLeaving","transitionOnMount","cloneElement","visible","_prevChild$props","_proto","prototype","render","ElementType","rest","createElement","Component","handledProps","default","propTypes","process","env","NODE_ENV","as","elementType","oneOfType","oneOf","TRANSITIONS","string","node","bool","number","shape","hide","isRequired","show","defaultProps","Fragment"],"sources":["/home/runner/work/jeopardy/jeopardy/node_modules/semantic-ui-react/dist/es/modules/Transition/TransitionGroup.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _values from \"lodash-es/values\";\nimport _get from \"lodash-es/get\";\nimport _has from \"lodash-es/has\";\nimport _forEach from \"lodash-es/forEach\";\nimport _mapValues from \"lodash-es/mapValues\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { getElementType, getUnhandledProps, SUI } from '../../lib';\nimport { getChildMapping, mergeChildMappings } from './utils/childMapping';\nimport wrapChild from './utils/wrapChild';\n\n/**\n * A Transition.Group animates children as they mount and unmount.\n */\nvar TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TransitionGroup, _React$Component);\n\n  function TransitionGroup() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      // Keeping a callback under the state is a hack to make it accessible under getDerivedStateFromProps()\n      handleOnHide: function handleOnHide(nothing, childProps) {\n        var reactKey = childProps.reactKey;\n\n        _this.setState(function (state) {\n          var children = _extends({}, state.children);\n\n          delete children[reactKey];\n          return {\n            children: children\n          };\n        });\n      }\n    };\n    return _this;\n  }\n\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var animation = props.animation,\n        duration = props.duration,\n        directional = props.directional;\n    var prevMapping = state.children; // A short circuit for an initial render as there will be no `prevMapping`\n\n    if (typeof prevMapping === 'undefined') {\n      return {\n        children: _mapValues(getChildMapping(props.children), function (child) {\n          return wrapChild(child, state.handleOnHide, {\n            animation: animation,\n            duration: duration,\n            directional: directional\n          });\n        })\n      };\n    }\n\n    var nextMapping = getChildMapping(props.children);\n    var children = mergeChildMappings(prevMapping, nextMapping);\n\n    _forEach(children, function (child, key) {\n      var hasPrev = _has(prevMapping, key);\n\n      var hasNext = _has(nextMapping, key);\n\n      var prevChild = prevMapping[key];\n      var isLeaving = !_get(prevChild, 'props.visible'); // Heads up!\n      // An item is new (entering), it will be picked from `nextChildren`, so it should be wrapped\n\n      if (hasNext && (!hasPrev || isLeaving)) {\n        children[key] = wrapChild(child, state.handleOnHide, {\n          animation: animation,\n          duration: duration,\n          directional: directional,\n          transitionOnMount: true\n        });\n        return;\n      } // Heads up!\n      // An item is old (exiting), it will be picked from `prevChildren`, so it has been already\n      // wrapped, so should be only updated\n\n\n      if (!hasNext && hasPrev && !isLeaving) {\n        children[key] = /*#__PURE__*/React.cloneElement(prevChild, {\n          visible: false\n        });\n        return;\n      } // Heads up!\n      // An item item hasn't changed transition states, but it will be picked from `nextChildren`,\n      // so we should wrap it again\n\n\n      var _prevChild$props = prevChild.props,\n          visible = _prevChild$props.visible,\n          transitionOnMount = _prevChild$props.transitionOnMount;\n      children[key] = wrapChild(child, state.handleOnHide, {\n        animation: animation,\n        duration: duration,\n        directional: directional,\n        transitionOnMount: transitionOnMount,\n        visible: visible\n      });\n    });\n\n    return {\n      children: children\n    };\n  };\n\n  var _proto = TransitionGroup.prototype;\n\n  _proto.render = function render() {\n    var children = this.state.children;\n    var ElementType = getElementType(TransitionGroup, this.props);\n    var rest = getUnhandledProps(TransitionGroup, this.props);\n    return /*#__PURE__*/React.createElement(ElementType, rest, _values(children));\n  };\n\n  return TransitionGroup;\n}(React.Component);\n\nTransitionGroup.handledProps = [\"animation\", \"as\", \"children\", \"directional\", \"duration\"];\nexport { TransitionGroup as default };\nTransitionGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** An element type to render as (string or function). */\n  as: PropTypes.elementType,\n\n  /** Named animation event to used. Must be defined in CSS. */\n  animation: PropTypes.oneOfType([PropTypes.oneOf(SUI.TRANSITIONS), PropTypes.string]),\n\n  /** Primary content. */\n  children: PropTypes.node,\n\n  /** Whether it is directional animation event or not. Use it only for custom transitions. */\n  directional: PropTypes.bool,\n\n  /** Duration of the CSS transition animation in milliseconds. */\n  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    hide: PropTypes.number.isRequired,\n    show: PropTypes.number.isRequired\n  }), PropTypes.string])\n} : {};\nTransitionGroup.defaultProps = {\n  as: React.Fragment,\n  animation: 'fade',\n  duration: 500\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}